name: ci

on:
  push:
    branches: ["main", "master"]
  pull_request:

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - name: Toolchain info
        run: |
          echo "Using OpenSSL:"
          openssl version || true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install elan (Lean toolchain)
        run: |
          curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf \
            | sh -s -- -y --default-toolchain=$(cat lean-toolchain)
          echo "$HOME/.elan/bin" >> $GITHUB_PATH

      - name: Fetch mathlib cache
        run: |
          lake update
          lake exe cache get

      - name: Build
        run: lake build

      - name: Lean tests
        run: lake env lean Tests/Main.lean

      - name: Docs & task cards
        run: |
          npm ci || true
          [ -f docs/cli.md ]
          [ -f docs/model-ir.md ]
          [ -f docs/invariants.md ]
          grep -q "docs/cli.md" README.md
          grep -q "veribiota import" docs/cli.md

      - name: Prepare signing material
        env:
          VERIBIOTA_SIG_KEY: ${{ secrets.VERIBIOTA_SIG_KEY }}
          VERIBIOTA_JWKS_JSON: ${{ secrets.VERIBIOTA_JWKS_JSON }}
        run: |
          set -euo pipefail
          if [[ -z "${VERIBIOTA_SIG_KEY:-}" ]]; then
            echo "VERIBIOTA_SIG_KEY secret is required to produce signed artifacts." >&2
            exit 1
          fi
          if [[ -z "${VERIBIOTA_JWKS_JSON:-}" ]]; then
            echo "VERIBIOTA_JWKS_JSON secret is required to verify signatures." >&2
            exit 1
          fi
          mkdir -p security
          key_path="$PWD/security/ci_signing.key"
          kid="veribiota-prod-2025-q1"
          printf '%s\n' "$VERIBIOTA_SIG_KEY" > "$key_path"
          chmod 600 "$key_path"
          printf '%s\n' "$VERIBIOTA_JWKS_JSON" > security/jwks.json
          pub_der="$(mktemp)"
          openssl pkey -in "$key_path" -pubout -outform DER -out "$pub_der"
          python3 - <<'PY' "$pub_der" security/jwks.json "$kid"
          import base64, json, sys
          from pathlib import Path
          der_path, jwks_path, kid = sys.argv[1:]
          prefix = bytes([0x30, 0x2a, 0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70, 0x03, 0x21, 0x00])
          der = Path(der_path).read_bytes()
          if not der.startswith(prefix):
              raise SystemExit("Unexpected Ed25519 DER header when deriving JWKS.")
          raw = der[len(prefix):]
          derived = base64.urlsafe_b64encode(raw).decode().rstrip("=")
          doc = json.loads(Path(jwks_path).read_text())
          target = None
          for key in doc.get("keys", []):
              if key.get("kid") == kid:
                  target = key.get("x")
                  break
          if target is None:
              raise SystemExit(f"JWKS is missing key id '{kid}'.")
          if derived != target:
              raise SystemExit(
                  "VERIBIOTA_JWKS_JSON does not match the configured signing key. "
                  "Update the JWKS secret to the public key paired with VERIBIOTA_SIG_KEY."
              )
          PY
          rm -f "$pub_der"
          {
            echo "VERIBIOTA_SIG_KEY=$key_path"
            echo "VERIBIOTA_SIG_KID=$kid"
          } >> "$GITHUB_ENV"

      - name: Emit artifacts (signed-soft)
        run: make sign-soft

      - name: Determinism (clone artifacts)
        run: cp -r build/artifacts build/artifacts.first

      - name: Determinism (re-emit)
        run: make sign-soft

      - name: Determinism (diff)
        run: |
          diff -u <(jq -S 'del(.signature.issuedAt, .signature.jws)' build/artifacts.first/checks/sir-demo.json) \
                  <(jq -S 'del(.signature.issuedAt, .signature.jws)' build/artifacts/checks/sir-demo.json)
          diff -u <(jq -S 'del(.signature.issuedAt, .signature.jws)' build/artifacts.first/certificates/sir-demo.json) \
                  <(jq -S 'del(.signature.issuedAt, .signature.jws)' build/artifacts/certificates/sir-demo.json)

      - name: Import sample model (separate out dir)
        run: |
          ./veribiota import --in Biosim/Examples/Model/sir.model.json \
            --emit-all --out build/imported \
            --sig-mode signed-soft \
            --sign-key "$VERIBIOTA_SIG_KEY" \
            --sign-kid "$VERIBIOTA_SIG_KID"

      - name: Canonicalize & validate schemas
        run: |
          ./veribiota --canon build/artifacts/checks/sir-demo.json \
            --out build/artifacts/checks/sir-demo.json
          ./veribiota --canon build/artifacts/certificates/sir-demo.json \
            --out build/artifacts/certificates/sir-demo.json
          node scripts/schemaValidate.mjs

      - name: Tamper harness
        run: |
          set -euo pipefail
          bash tests/scripts/tamper.sh build/artifacts/checks/sir-demo.json
          ./veribiota --canon build/artifacts/checks/sir-demo.flip_payload.json \
            --out build/artifacts/checks/sir-demo.flip_payload.json
          ./veribiota --canon build/artifacts/checks/sir-demo.flip_sig.json \
            --out build/artifacts/checks/sir-demo.flip_sig.json
          set +e
          ./veribiota verify checks build/artifacts/checks/sir-demo.flip_payload.json --jwks security/jwks.json --sig-mode signed-enforced
          status=$?
          set -e
          if [[ $status -ne 3 ]]; then
            echo "Expected exit code 3 for payload tamper, got $status" >&2
            exit 1
          fi
          set +e
          ./veribiota verify checks build/artifacts/checks/sir-demo.flip_sig.json --jwks security/jwks.json --sig-mode signed-enforced
          status=$?
          set -e
          if [[ $status -ne 2 ]]; then
            echo "Expected exit code 2 for signature tamper, got $status" >&2
            exit 1
          fi

      - name: CRLF canonicalization
        run: |
          set -euo pipefail
          awk 'sub("$","\r")' build/artifacts/checks/sir-demo.json > build/artifacts/checks/sir-demo.crlf.json
          ./veribiota --canon build/artifacts/checks/sir-demo.crlf.json --out build/artifacts/checks/sir-demo.canon.json
          diff -u build/artifacts/checks/sir-demo.json build/artifacts/checks/sir-demo.canon.json

      - name: SHA capture
        run: |
          (sha256sum build/artifacts/models/*.json build/artifacts/certificates/*.json build/artifacts/checks/*.json) || (shasum -a 256 build/artifacts/models/*.json build/artifacts/certificates/*.json build/artifacts/checks/*.json)

      - name: Tarball artifacts
        if: github.ref == 'refs/heads/main' && matrix.os == 'ubuntu-latest'
        run: |
          tar -C build -czf artifacts.tgz artifacts

      - name: Upload build artifacts
        if: github.ref == 'refs/heads/main' && matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: veribiota-artifacts
          path: artifacts.tgz

  release:
    needs: build-test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install elan (Lean toolchain)
        run: |
          curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf \
            | sh -s -- -y --default-toolchain=$(cat lean-toolchain)
          echo "$HOME/.elan/bin" >> $GITHUB_PATH

      - name: Fetch mathlib cache
        run: |
          lake update
          lake exe cache get

      - name: Prepare signing material
        env:
          VERIBIOTA_SIG_KEY: ${{ secrets.VERIBIOTA_SIG_KEY }}
          VERIBIOTA_JWKS_JSON: ${{ secrets.VERIBIOTA_JWKS_JSON }}
        run: |
          set -euo pipefail
          if [[ -z "${VERIBIOTA_SIG_KEY:-}" ]]; then
            echo "VERIBIOTA_SIG_KEY secret is required to ship signed releases." >&2
            exit 1
          fi
          if [[ -z "${VERIBIOTA_JWKS_JSON:-}" ]]; then
            echo "VERIBIOTA_JWKS_JSON secret is required to verify release signatures." >&2
            exit 1
          fi
          mkdir -p security
          key_path="$PWD/security/release_signing.key"
          kid="veribiota-prod-2025-q1"
          printf '%s\n' "$VERIBIOTA_SIG_KEY" > "$key_path"
          chmod 600 "$key_path"
          printf '%s\n' "$VERIBIOTA_JWKS_JSON" > security/jwks.json
          pub_der="$(mktemp)"
          openssl pkey -in "$key_path" -pubout -outform DER -out "$pub_der"
          python3 - <<'PY' "$pub_der" security/jwks.json "$kid"
          import base64, json, sys
          from pathlib import Path
          der_path, jwks_path, kid = sys.argv[1:]
          prefix = bytes([0x30, 0x2a, 0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70, 0x03, 0x21, 0x00])
          der = Path(der_path).read_bytes()
          if not der.startswith(prefix):
              raise SystemExit("Unexpected Ed25519 DER header when deriving JWKS.")
          raw = der[len(prefix):]
          derived = base64.urlsafe_b64encode(raw).decode().rstrip("=")
          doc = json.loads(Path(jwks_path).read_text())
          target = None
          for key in doc.get("keys", []):
              if key.get("kid") == kid:
                  target = key.get("x")
                  break
          if target is None:
              raise SystemExit(f"JWKS is missing key id '{kid}'.")
          if derived != target:
              raise SystemExit(
                  "VERIBIOTA_JWKS_JSON does not match the configured signing key. "
                  "Update the JWKS secret to the public key paired with VERIBIOTA_SIG_KEY."
              )
          PY
          rm -f "$pub_der"
          {
            echo "VERIBIOTA_SIG_KEY=$key_path"
            echo "VERIBIOTA_SIG_KID=$kid"
            echo "VERIBIOTA_SIG_MODE=signed-soft"
          } >> "$GITHUB_ENV"

      - name: Sign-soft & verify
        run: |
          make sign-soft verify
          tar -czf artifacts.tgz build/artifacts

      - uses: softprops/action-gh-release@v2
        with:
          tag_name: nightly
          files: artifacts.tgz
